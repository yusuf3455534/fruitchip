.define PUBLIC BOOT_ROM_READ_SNIFFER_SM 0
.define PUBLIC BOOT_ROM_WRITE_SNIFFER_SM 1
.define PUBLIC BOOT_ROM_DATA_OUT_SM 2

.define PUBLIC BOOT_ROM_BYTE_OUT_IRQ 0

// MX29LV320E is used in a boot rom replacement flex board, so it appears to be compatible

.program boot_rom_read_sniffer
.side_set 1 opt
    mov osr null // prepare to switch OUT (Q0-Q7) to input
    out pindirs, 8 side 0 // set OUT (Q0-Q7) to 0 (input), SIDE (LED) to 0 (off)
.wrap_target
ce_high:
    wait 0 gpio ${BOOT_ROM_OE_PIN} [5] // 20.83 ns @ 240 MHz
    jmp pin ce_high
ce_low:
    in pins, 8
    wait 1 gpio ${BOOT_ROM_OE_PIN}
.wrap

// 6 instructions

// watching writes on a ROM, you may ask,
// writing into BOOT ROM area will still result
// in write command being send over the wire,
// IC will reject it, but we can observe it.
//
// multiple writes one after the other
// will end up holding CE low the entire time.
// since we don't have WE wired up,
// we can only see the last byte.
.program boot_rom_write_sniffer
start:
    wait 1 gpio ${BOOT_ROM_CE_PIN} // move this here to save an instruction (instead of duplicating it in `oe_low` and `oe_high`)
    wait 0 gpio ${BOOT_ROM_CE_PIN} [10] // wait for OE (41.67 ns @ 240 MHz)
    jmp pin oe_high
oe_low:
    jmp start
    // read command, ignore, wait for CE to go up
oe_high:
    // probably write, read first pulse
    in pins, 8
    // skip the rest, wait for CE to go up
// 5 instructions, 11 total

// DMA to TX FIFO is padded by dummy value,
// when it's pulled into OSR, FIFO becomes empty,
// which signals IRQ to stop the SM
.program boot_rom_data_out
.side_set 1 opt
    mov osr !null side 1 // prepare to switch OUT (Q0-Q7) to output, set SIDE (LED) to 1 (on)
    out null, 24 // only need 8 bits, discard the rest of OSR
ce_high1:
    wait 0 gpio ${BOOT_ROM_OE_PIN}
    jmp pin ce_high1
    out pindirs, 8  // set OUT (Q0-Q7) to 1 (output)
    pull ifempty block
.wrap_target
    out pins, 8
    pull ifempty block
    wait 1 gpio ${BOOT_ROM_OE_PIN}
ce_high2:
    wait 0 gpio ${BOOT_ROM_OE_PIN}
    jmp pin ce_high2
    irq nowait BOOT_ROM_BYTE_OUT_IRQ
.wrap

// 12 instructions, 23 total, 9 remaining

% c-sdk {
static const uint8_t boot_rom_read_sniffer_program_instructions_count = sizeof(boot_rom_read_sniffer_program_instructions) / sizeof(*boot_rom_read_sniffer_program_instructions);
static const uint8_t boot_rom_write_sniffer_program_instructions_count = sizeof(boot_rom_write_sniffer_program_instructions) / sizeof(*boot_rom_write_sniffer_program_instructions);
static const uint8_t boot_rom_data_out_program_instructions_count = sizeof(boot_rom_data_out_program_instructions) / sizeof(*boot_rom_data_out_program_instructions);

// calculate offsets statically to help avoid runtime calculations
static const uint8_t boot_rom_read_sniffer_offset = 32 - boot_rom_read_sniffer_program_instructions_count;
static const uint8_t boot_rom_write_sniffer_offset = boot_rom_read_sniffer_offset - boot_rom_write_sniffer_program_instructions_count;
static const uint8_t boot_rom_data_out_offset = boot_rom_write_sniffer_offset - boot_rom_data_out_program_instructions_count;

static inline void boot_rom_pio_gpio_init(PIO pio)
{
    pio_gpio_init(pio, ${BOOT_ROM_Q0_PIN} + 0);
    pio_gpio_init(pio, ${BOOT_ROM_Q0_PIN} + 1);
    pio_gpio_init(pio, ${BOOT_ROM_Q0_PIN} + 2);
    pio_gpio_init(pio, ${BOOT_ROM_Q0_PIN} + 3);
    pio_gpio_init(pio, ${BOOT_ROM_Q0_PIN} + 4);
    pio_gpio_init(pio, ${BOOT_ROM_Q0_PIN} + 5);
    pio_gpio_init(pio, ${BOOT_ROM_Q0_PIN} + 6);
    pio_gpio_init(pio, ${BOOT_ROM_Q0_PIN} + 7);
    pio_gpio_init(pio, ${BOOT_ROM_CE_PIN});
    pio_gpio_init(pio, ${BOOT_ROM_OE_PIN});
}

static inline void boot_rom_read_sniffer_sm_init_and_start(PIO pio, uint sm, uint offset)
{
    boot_rom_pio_gpio_init(pio);
    pio_gpio_init(pio, PICO_DEFAULT_LED_PIN);

    pio_sm_config cfg = boot_rom_read_sniffer_program_get_default_config(offset);

    sm_config_set_out_pins(&cfg, ${BOOT_ROM_Q0_PIN}, 8);
    sm_config_set_in_pins(&cfg, ${BOOT_ROM_Q0_PIN});
    sm_config_set_in_shift(&cfg, false, true, 8); /* shift ISR to left, autopush every 8 bits */
    sm_config_set_fifo_join(&cfg, PIO_FIFO_JOIN_RX);

    sm_config_set_jmp_pin(&cfg, ${BOOT_ROM_CE_PIN});
    sm_config_set_sideset_pin_base(&cfg, PICO_DEFAULT_LED_PIN);

    pio_sm_set_consecutive_pindirs(pio, sm, ${BOOT_ROM_Q0_PIN}, 8, GPIO_IN);
    pio_sm_set_consecutive_pindirs(pio, sm, ${BOOT_ROM_CE_PIN}, 1, GPIO_IN);
    pio_sm_set_consecutive_pindirs(pio, sm, ${BOOT_ROM_OE_PIN}, 1, GPIO_IN);
    pio_sm_set_consecutive_pindirs(pio, sm, PICO_DEFAULT_LED_PIN, 1, GPIO_OUT);

    pio_sm_init(pio, sm, offset, &cfg);
    pio_sm_set_enabled(pio, sm, true);
}

static inline void boot_rom_write_sniffer_sm_init_and_start(PIO pio, uint sm, uint offset)
{
    boot_rom_pio_gpio_init(pio);

    pio_sm_config cfg = boot_rom_write_sniffer_program_get_default_config(offset);

    sm_config_set_in_pins(&cfg, ${BOOT_ROM_Q0_PIN});
    sm_config_set_in_shift(&cfg, false, true, 8); /* shift ISR to left, autopush every 8 bits */
    sm_config_set_fifo_join(&cfg, PIO_FIFO_JOIN_RX);

    sm_config_set_jmp_pin(&cfg, ${BOOT_ROM_OE_PIN});

    pio_sm_set_consecutive_pindirs(pio, sm, ${BOOT_ROM_Q0_PIN}, 8, GPIO_IN);
    pio_sm_set_consecutive_pindirs(pio, sm, ${BOOT_ROM_CE_PIN}, 1, GPIO_IN);
    pio_sm_set_consecutive_pindirs(pio, sm, ${BOOT_ROM_OE_PIN}, 1, GPIO_IN);

    pio_sm_init(pio, sm, offset, &cfg);
    pio_sm_set_enabled(pio, sm, true);
}

static inline void boot_rom_data_out_sm_init(PIO pio, uint sm, uint offset)
{
    boot_rom_pio_gpio_init(pio);
    pio_gpio_init(pio, PICO_DEFAULT_LED_PIN);

    pio_sm_config cfg = boot_rom_data_out_program_get_default_config(offset);

    sm_config_set_out_pins(&cfg, ${BOOT_ROM_Q0_PIN}, 8);
    sm_config_set_out_special(&cfg, true, false, false); // set sticky output, we need to hold data until rising edge
    sm_config_set_out_shift(&cfg, true, false, 8); // shift OSR to right, no autopull, 8 bits threshold
    sm_config_set_fifo_join(&cfg, PIO_FIFO_JOIN_TX);

    sm_config_set_jmp_pin(&cfg, ${BOOT_ROM_CE_PIN});
    sm_config_set_sideset_pin_base(&cfg, PICO_DEFAULT_LED_PIN);


    // start data pins in input, `boot_rom_data_pindirs_switcher` will switch direction as needed
    pio_sm_set_consecutive_pindirs(pio, sm, ${BOOT_ROM_Q0_PIN}, 8, GPIO_IN);
    pio_sm_set_consecutive_pindirs(pio, sm, ${BOOT_ROM_CE_PIN}, 1, GPIO_IN);
    pio_sm_set_consecutive_pindirs(pio, sm, ${BOOT_ROM_OE_PIN}, 1, GPIO_IN);
    pio_sm_set_consecutive_pindirs(pio, sm, PICO_DEFAULT_LED_PIN, 1, GPIO_OUT);

    pio_sm_init(pio, sm, offset, &cfg);
    pio_sm_set_enabled(pio, sm, false);
}
%}